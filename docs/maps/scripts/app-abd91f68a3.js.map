{"version":3,"sources":["scripts/app.js"],"names":["angular","module","runBlock","$log","debug","$inject","run","directive","link","scope","element","attr","snapLocations","JSON","parse","restPosition","positionX","calculate_snap_location","position","currentDiff","minimumDiff","bestSnap","i","length","Math","abs","undefined","Hammer","on","ev","removeClass","parseInt","gesture","deltaX","css","addClass"],"mappings":"CAAA,WACE,YAEAA,SACGC,OAAO,uBAAwB,oBAIpC,WACE,YAOA,SAASC,GAASC,GAEhBA,EAAKC,MAAM,gBAPbF,EAASG,SAAW,QAApBL,QACGC,OAAO,uBACPK,IAAIJ,MAUT,WACI,YAEAF,SAAQC,OAAO,mBACVM,UAAU,eAAgB,WACvB,OAEIC,KAAM,SAAUC,EAAOC,EAASC,GAE5B,GAAIC,GAAgBC,KAAKC,MAAMH,EAAKC,eAChCG,EAAe,EACfC,EAAY,EAgBZC,EAA0B,SAAUC,GAapC,IAAK,GAVDC,GAGAC,EAGAC,EAIKC,EAAI,EAAGA,EAAIV,EAAcW,OAAQD,IAGtCH,EAAcK,KAAKC,IAAIT,EAAYJ,EAAcU,KAG7BI,SAAhBN,GAA2CA,EAAdD,KAC7BC,EAAcD,EACdE,EAAWT,EAAcU,GAIjC,OAAOD,GAMXM,QAAOjB,EAAQ,IAAIkB,GAAG,YAAa,SAAUC,GAGzCnB,EAAQoB,YAAY,aAMxBH,OAAOjB,EAAQ,IAAIkB,GAAG,OAAQ,SAAUC,GAGpCb,EAAYD,EAAegB,SAASF,EAAGG,QAAQC,QAE/CvB,EAAQwB,IAAI,oBAAqB,eAAiBlB,EAAY,eAC9DN,EAAQwB,IAAI,YAAa,eAAiBlB,EAAY,iBAM1DW,OAAOjB,EAAQ,IAAIkB,GAAG,UAAW,SAAUC,GACvCnB,EAAQyB,SAAS,WAGjBpB,EAAeE,EAAwBD,GAEvCN,EAAQwB,IAAI,oBAAqB,eAAiBnB,EAAe","file":"scripts/app-abd91f68a3.js","sourcesContent":["(function() {\n  'use strict';\n\n  angular\n    .module('angularSwipeAndSnap', ['swipeAndSnap']);\n\n})();\n\n(function() {\n  'use strict';\n\n  angular\n    .module('angularSwipeAndSnap')\n    .run(runBlock);\n\n  /** @ngInject */\n  function runBlock($log) {\n\n    $log.debug('runBlock end');\n  }\n\n})();\n\n(function () {\n    'use strict';\n\n    angular.module('swipeAndSnap', [])\n        .directive('swipeAndSnap', function () {\n            return {\n\n                link: function (scope, element, attr) {\n\n                    var snapLocations = JSON.parse(attr.snapLocations),\n                        restPosition = 0, // Define the location to end.\n                        positionX = 0; // The current position.\n\n                    /**\n                     * Calculate the snap location.\n                     *\n                     * Called on drag end to work out where to animate\n                     * the div to.\n                     *\n                     * @function\n                     *\n                     * @param {number} position\n                     * The current position.\n                     *\n                     * @returns {number}\n                     * The position to snap to.\n                     */\n                    var calculate_snap_location = function (position) {\n\n                        // Used to store each difference between current position and each snap point.\n                        var currentDiff;\n\n                        // Used to store the current best difference.\n                        var minimumDiff;\n\n                        // User to store the best snap position.\n                        var bestSnap;\n\n                        // We're going to cycle through each snap location\n                        // and work out which is closest to the current position.\n                        for (var i = 0; i < snapLocations.length; i++) {\n\n                            // Calculate the difference.\n                            currentDiff = Math.abs(positionX - snapLocations[i]);\n\n                            // Works out if this difference is the closest yet.\n                            if (minimumDiff === undefined || currentDiff < minimumDiff) {\n                                minimumDiff = currentDiff;\n                                bestSnap = snapLocations[i];\n                            }\n                        }\n\n                        return bestSnap;\n                    };\n\n                    /**\n                     * Perform any setup for the drag actions.\n                     */\n                    Hammer(element[0]).on(\"dragstart\", function (ev) {\n\n                        // We dont want an animation delay when dragging.\n                        element.removeClass('animate');\n                    });\n\n                    /**\n                     * Follow the drag position when the user is interacting.\n                     */\n                    Hammer(element[0]).on(\"drag\", function (ev) {\n\n                        // Set the current position.\n                        positionX = restPosition + parseInt(ev.gesture.deltaX);\n\n                        element.css('-webkit-transform', 'translate3d(' + positionX + 'px,0px,0px)');\n                        element.css('transform', 'translate3d(' + positionX + 'px,0px,0px)');\n                    });\n\n                    /**\n                     * The drag is finishing so we'll animate to a snap point.\n                     */\n                    Hammer(element[0]).on(\"dragend\", function (ev) {\n                        element.addClass('animate');\n\n                        // Work out where we should \"snap\" to.\n                        restPosition = calculate_snap_location(positionX);\n\n                        element.css('-webkit-transform', 'translate3d(' + restPosition + 'px, 0px, 0px)');\n                    });\n                }\n            };\n        });\n\n})();\n"],"sourceRoot":"/source/"}