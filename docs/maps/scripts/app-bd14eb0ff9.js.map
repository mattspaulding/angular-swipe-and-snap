{"version":3,"sources":["scripts/app.js"],"names":["angular","module","runBlock","$log","debug","$inject","run","directive","link","scope","element","attr","snapLocations","JSON","parse","positionX","calculate_snap_location","position","currentDiff","minimumDiff","bestSnap","i","length","Math","abs","undefined","Hammer","on","ev","removeClass","$broadcast","parseInt","restPos","gesture","deltaX","css","addClass","snapLocation"],"mappings":"CAAA,WACE,YAEAA,SACGC,OAAO,uBAAwB,oBAIpC,WACE,YAOA,SAASC,GAASC,GAEhBA,EAAKC,MAAM,gBAPbF,EAASG,SAAW,QAApBL,QACGC,OAAO,uBACPK,IAAIJ,MAUT,WACE,YAEAF,SAAQC,OAAO,mBACZM,UAAU,eAAgB,WACzB,OAEEC,KAAM,SAAUC,EAAOC,EAASC,GAE9B,GAAIC,GAAgBC,KAAKC,MAAMH,EAAKC,eAElCG,EAAY,EAgBVC,EAA0B,SAAUC,GAatC,IAAK,GAVDC,GAGAC,EAGAC,EAIKC,EAAI,EAAGA,EAAIT,EAAcU,OAAQD,IAGxCH,EAAcK,KAAKC,IAAIT,EAAYH,EAAcS,KAG7BI,SAAhBN,GAA2CA,EAAdD,KAC/BC,EAAcD,EACdE,EAAWR,EAAcS,GAI7B,OAAOD,GAMTM,QAAOhB,EAAQ,IAAIiB,GAAG,YAAa,SAAUC,GAG3ClB,EAAQmB,YAAY,WAGpBpB,EAAMqB,WAAW,eAOnBJ,OAAOhB,EAAQ,IAAIiB,GAAG,OAAQ,SAAUC,GAGtCb,EAAYgB,SAAStB,EAAMuB,SAAWD,SAASH,EAAGK,QAAQC,QAE1DxB,EAAQyB,IAAI,oBAAqB,eAAiBpB,EAAY,eAC9DL,EAAQyB,IAAI,YAAa,eAAiBpB,EAAY,iBAMxDW,OAAOhB,EAAQ,IAAIiB,GAAG,UAAW,SAAUC,GACzClB,EAAQ0B,SAAS,WAGjB3B,EAAMuB,QAAUhB,EAAwBD,GAExCL,EAAQyB,IAAI,oBAAqB,eAAiB1B,EAAMuB,QAAU,iBAGlEvB,EAAMqB,WAAW,WAAYO,aAAc5B,EAAMuB","file":"scripts/app-bd14eb0ff9.js","sourcesContent":["(function() {\n  'use strict';\n\n  angular\n    .module('angularSwipeAndSnap', ['swipeAndSnap']);\n\n})();\n\n(function() {\n  'use strict';\n\n  angular\n    .module('angularSwipeAndSnap')\n    .run(runBlock);\n\n  /** @ngInject */\n  function runBlock($log) {\n\n    $log.debug('runBlock end');\n  }\n\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('swipeAndSnap', [])\n    .directive('swipeAndSnap', function () {\n      return {\n\n        link: function (scope, element, attr) {\n\n          var snapLocations = JSON.parse(attr.snapLocations),\n            //restPosition = 0, // Define the location to end.\n            positionX = 0; // The current position.\n\n          /**\n           * Calculate the snap location.\n           *\n           * Called on drag end to work out where to animate\n           * the div to.\n           *\n           * @function\n           *\n           * @param {number} position\n           * The current position.\n           *\n           * @returns {number}\n           * The position to snap to.\n           */\n          var calculate_snap_location = function (position) {\n\n            // Used to store each difference between current position and each snap point.\n            var currentDiff;\n\n            // Used to store the current best difference.\n            var minimumDiff;\n\n            // User to store the best snap position.\n            var bestSnap;\n\n            // We're going to cycle through each snap location\n            // and work out which is closest to the current position.\n            for (var i = 0; i < snapLocations.length; i++) {\n\n              // Calculate the difference.\n              currentDiff = Math.abs(positionX - snapLocations[i]);\n\n              // Works out if this difference is the closest yet.\n              if (minimumDiff === undefined || currentDiff < minimumDiff) {\n                minimumDiff = currentDiff;\n                bestSnap = snapLocations[i];\n              }\n            }\n\n            return bestSnap;\n          };\n\n          /**\n           * Perform any setup for the drag actions.\n           */\n          Hammer(element[0]).on(\"dragstart\", function (ev) {\n\n            // We dont want an animation delay when dragging.\n            element.removeClass('animate');\n\n            // Brodcast dragstart\n            scope.$broadcast('dragstart');\n\n          });\n\n          /**\n           * Follow the drag position when the user is interacting.\n           */\n          Hammer(element[0]).on(\"drag\", function (ev) {\n\n            // Set the current position.\n            positionX = parseInt(scope.restPos) + parseInt(ev.gesture.deltaX);\n\n            element.css('-webkit-transform', 'translate3d(' + positionX + 'px,0px,0px)');\n            element.css('transform', 'translate3d(' + positionX + 'px,0px,0px)');\n          });\n\n          /**\n           * The drag is finishing so we'll animate to a snap point.\n           */\n          Hammer(element[0]).on(\"dragend\", function (ev) {\n            element.addClass('animate');\n\n            // Work out where we should \"snap\" to.\n            scope.restPos = calculate_snap_location(positionX);\n\n            element.css('-webkit-transform', 'translate3d(' + scope.restPos + 'px, 0px, 0px)');\n\n            // Broadcast dragend\n            scope.$broadcast('dragend', {snapLocation: scope.restPos});\n          });\n        }\n      }\n    });\n\n})();\n"],"sourceRoot":"/source/"}